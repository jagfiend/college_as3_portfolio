package classes.game // class controls the gameplay screen and state{	// import libraries and classes...	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.KeyboardEvent;	// gameplay state elements...	import classes.controller.KeyboardController;	import classes.game.PauseMenu;	import classes.app.App;	// sound manager..	import classes.sound.SoundManager;	// background elements...	import classes.game.TheSky;	import classes.game.TheGround;	// player elements...	import classes.game.GameCursor;	import classes.game.DarkMatter;	import classes.game.Colony;	import classes.game.Smoke;	import classes.game.Target;	import classes.game.Projectile;	import classes.game.ProjectileExplosion;	// text field elements...	import classes.game.HeadsUp;	// enemy elements...	import classes.game.Missile;	import classes.game.MissileExplosion;	// class code...	public class Game extends MovieClip	{		// class variables...		// variables...		// for gamestate and pause functionality...		private var _app:App;		private var _keyControl:KeyboardController;		public var _isPaused:Boolean = false; // controls state of gameplay...		private var _pauseMenu:PauseMenu;		// for sound management...		private var _soundManager:SoundManager = SoundManager.getInstance();		// for ui text fields...		private var _waveCount:int = 1;		private var _scoreCount:int = 0;		private var _ammoCount:int = 12;		private var _salvoSize:int = 6;		private var _textFields:HeadsUp;		// for backgroud...		private var _sky:TheSky;		private var _ground:TheGround;		// for counter and cursor...		private var _counter:int = 0;		private var _pauseCounter:int = 0;		private var _gameCursor:GameCursor;		// player objects...		private var _darkMatter:DarkMatter;		private var _colony:Colony;		private var _smoke:Smoke;		// arrays...		private var _colonies:Array = new Array;		private var _colonyPositions:Array = [100,250,550,700]; // defines x positions of colony objects...		private var _targets:Array = new Array;		private var _projectiles:Array = new Array;		private var _projectileExplosions:Array = new Array;		private var _missiles:Array = new Array;		private var _missileExplosions:Array = new Array;		// class methods...		public function Game(app:App) 		{			// constructor code..			_app = app;			addEventListener(Event.ADDED_TO_STAGE, onAdded);			addEventListener(Event.REMOVED_FROM_STAGE, onRemove);		} 				private function onRemove(e:Event):void		{			// remove listeners...			removeEventListener(Event.REMOVED_FROM_STAGE, onRemove);			removeGameListeners();		}		private function onAdded(e:Event):void 		{			removeEventListener(Event.ADDED_TO_STAGE, onAdded);			init();		}				private function init():void 		{			// setup the keyboard...			setupKeyboard();			// add game music...			addGameMusic();			// draw background...			drawBackground();			// draw user interface...			drawUI();			// draw player objects...			drawPlayerObjects();			// add listeners...			addGameListeners();			// focus the stage...			stage.stageFocusRect = false;			stage.focus = stage;		}		/* SETUP AND BUILD FUNCTIONS */		private function setupKeyboard():void		{			_keyControl = new KeyboardController(this);			stage.addEventListener(KeyboardEvent.KEY_DOWN, _keyControl.downhandle);		}		private function addGameMusic():void		{			_soundManager.playSound("gameMusic",1,0,6);		}				private function drawBackground():void		{			// draw the sky...			_sky = new TheSky(this);			addChild(_sky);			// add background image...			_ground = new TheGround(this,0,0);			addChild(_ground);		}				private function drawUI():void		{			// add custom cursor...			_gameCursor = new GameCursor(this);			addChild(_gameCursor);			// add code for dynamic text fields...			_textFields = new HeadsUp();			addChild(_textFields);		} 				private function drawPlayerObjects():void		{			// add dark matter weapon...			_darkMatter = new DarkMatter(this);			addChild(_darkMatter);			// add colonies..			addColonies();		}				private function addColonies():void		{			// runs over colony position array to assign each one the appropriate x position...			for(var i:int = 0; i < _colonyPositions.length; i++)			{				var _colony:Colony = new Colony(this,_colonyPositions[i]);				addChild(_colony);				_colonies.push(_colony);			}		}		/* LISTENER FUNCTIONS */		private function addGameListeners():void		{			addEventListener(Event.ENTER_FRAME, onEnterFrame);			stage.addEventListener(MouseEvent.CLICK, onClick);		}				private function removeGameListeners():void		{			removeEventListener(Event.ENTER_FRAME, onEnterFrame);			stage.removeEventListener(MouseEvent.CLICK, onClick);		}			private function onEnterFrame(e:Event):void		{			if(_isPaused){				pauseGame(); // if the pause boolean is set, the pause game function is called...			} else {				if(_pauseMenu){					unpauseGame(); // checks for instance of pause menu; if exists, calls unpause function...				}				// counter and functions updating each frame...				_gameCursor.updateCursor(); // tracks custom cursor to mouse movement...				_counter++; // increments the counter variable each frame...				_pauseCounter++; // increments the pause counter each frame...				checkProjectiles(); // updates projectile movement...				updateProjectileExplosions(); // cleans the projectile explosions array...				waveHandler(); // launches waves of missiles and updates players score...				missileHandler(); // updates missile position and checks basic collision as well as calling more complex detection functions...				updateMissileExplosions(); // cleans the missiles explosions array				deathHandler(); // watches for end of game conditions (ie no colonies = game over)			}		}				private function onClick(e:MouseEvent):void		{			if(!_isPaused){ // checks if paused to remove a bug where player could add targets when the game is paused. NO CHEATING ALLOWED!				// adds a target to the stage if the player as ammo remaining...				if(_counter > 30 && _pauseCounter > 10 && ammoCount > 0){ // added _counter check to remove bug where click to start game is firing the weapon...					addTarget();					ammoCount = ammoCount - 1;				}			}		}		/* PAUSE STATE FUNCTIONS */		private function pauseGame():void		{			// pause sounds...			pauseSounds();			// calls pause menu			if(!_pauseMenu){				_pauseMenu = new PauseMenu(this,_app,0,0);				addChild(_pauseMenu);				// add menu cursor...				_app.drawMenuCursor();				// focus the menu...				stage.focus = _pauseMenu;			}		}				public function unpauseGame():void		{			// resume music			unpauseSounds();			// removes pause menu			_isPaused = false;			removeChild(_pauseMenu);			_pauseMenu = null;			// reset pause counter to prevent weapon firing from click of resume game button...			_pauseCounter = 0;			// remove menu cursor...			_app.removeMenuCursor();			// refocus the stage...			stage.focus = stage;		}		private function pauseSounds():void		{			_soundManager.pauseSound("gameMusic");			// _soundManager.pauseAllSounds(true); // this had been removed as there appears to be a bug in the soundmanager class...		}		private function unpauseSounds():void		{			_soundManager.playSound("gameMusic");			// _soundManager.playAllSounds(true); // this had been removed as there appears to be a bug in the soundmanager class...		}				/* DEATH CODE */		private function deathHandler():void		{			// checks the number player colonies remaining. If zero, records the players score and calls the gameover screen... 			if(_colonies.length < 1){ // using less than 1 rather than 0 equality to avoid potential listener bug				var score = _scoreCount.toString();				stopGameSounds();				_app.drawMenuBackground();				_app.drawGameOver(score);			}		}		public function stopGameSounds():void		{			_soundManager.stopSound("gameMusic");			// _soundManager.stopAllSounds(true); // this had been removed as there appears to be a bug in the soundmanager class...		}				/* //////// TEXT FIELD GETTERS AND SETTERS //////// */		// these half dozen functions set the values of the heads up display visible on the game screen...		// set wave count		public function set waveCount(val:int):void{			_waveCount = val;			_textFields._waveValue.txt.text = _waveCount;		}		// get wave count		public function get waveCount():int		{			return _waveCount;		}		// set score count		public function set scoreCount(val:int):void{			_scoreCount = val;			_textFields._scoreValue.txt.text = _scoreCount;		}		// get wave count		public function get scoreCount():int		{			return _scoreCount;		}		// set ammo count		public function set ammoCount(val:int):void{			_ammoCount = val;			_textFields._ammoValue.txt.text = _ammoCount;		}		// get ammo count		public function get ammoCount():int		{			return _ammoCount;		}		// these salvo functions update the number of missiles in each wave...		// set salvo size		private function set salvoSize(val:int):void{			_salvoSize = val;		}		// get salvo size		private function get salvoSize():int		{			return _salvoSize;		}				/* ////////// CODE FOR PLAYER OBJECTS /////////// */		/* TARGET CODE */		private function addTarget():void		{			// adds sound effect			_soundManager.playSound("target",0.2);			// initialise and draw target...			var _target:Target = new Target(this);			// add to stage...			addChild(_target);			// add at array...			_targets.push(_target);			// call function to launch projectile...			addProjectile();		}				private function removeTarget(index:Number):void		{			// removes the target once the projectile has arrived at its destination...			removeChild(_targets[index]); // remove from stage...			_targets[index] = null; // remove from memory...			_targets.splice(index,1); // remove from array...		}				/* PROJECTILE CODE */		private function addProjectile():void 		{			// adds sound effect			_soundManager.playSound("darkMatter",0.2);			// adds projectile that moves from dark matter weapon to target...			var _projectile:Projectile = new Projectile(this);			addChild(_projectile);			_projectiles.push(_projectile);		}				private function checkProjectiles():void		{			// runs over each instance of a projectile in the projectiles array every frame to move projectile to target...			for(var i:int = _projectiles.length - 1; i >= 0; i--)			{				var _projectile:Projectile = _projectiles[i];				updateProjectile(i,_projectile.x,_projectile.y);			}		}				private function updateProjectile(projectileIndex:Number,projectileXpos:Number,projectileYpos:Number):void				{			// check distance to target...			var dx:Number = (projectileXpos - _targets[projectileIndex].x); // links to corresponding target by the index number...			var dy:Number = (projectileYpos - _targets[projectileIndex].y);			var distanceToTarget:Number = Math.sqrt((dx*dx) + (dy*dy));			// number of steps required to reach target...			var scale:Number = 10 / distanceToTarget;			// update projectile position....			if(distanceToTarget > 5) // too glitchy below five pixels...			{				// code to move projectile to target until distance is zero...				_projectiles[projectileIndex].x -= dx * scale;				_projectiles[projectileIndex].y -= dy * scale;			} else {				// code for action when projectile reaches target...				// call creation of dark matter explosion...				var explosionXpos:Number = _targets[projectileIndex].x;				var explosionYpos:Number = _targets[projectileIndex].y;				addProjectileExplosion(explosionXpos,explosionYpos);				// remove target and projectile objects...				removeProjectile(projectileIndex);				removeTarget(projectileIndex);			}		}				private function removeProjectile(index:Number):void		{			removeChild(_projectiles[index]); // remove from stage...			_projectiles[index] = null; // remove from memory...			_projectiles.splice(index,1); // remove from array...		}				/* PROJECTILE EXPLOSION CODE */		private function addProjectileExplosion(xPos:Number,yPos:Number):void		{			addMissileSound();			var _projectileExplosion:ProjectileExplosion = new ProjectileExplosion(this,xPos,yPos);			addChild(_projectileExplosion);			_projectileExplosions.push(_projectileExplosion);		} 						private function updateProjectileExplosions():void		{			// monitors and maintains projectile explosions...			for(var i:int = _projectileExplosions.length - 1; i >= 0; i--)			{				var _projectileExplosion:ProjectileExplosion = _projectileExplosions[i];				// check removal flag status...				if(_projectileExplosions[i].removeMe == true){					removeChild(_projectileExplosions[i]); // remove from stage...					_projectileExplosions[i] = null; // remove from memory...					_projectileExplosions.splice(i,1); // remove from array...				}			}		}		private function addMissileSound():void		{			// adds sound effect			_soundManager.playSound("missileExplosion",0.2);		}				/* COLONY CODE */		private function removeColonyFromArray(index:Number):void		{			_colonies[index] = null; // remove from memory...			_colonies.splice(index,1); // remove from array...		}				/* ////////// CODE FOR ENEMY OBJECTS /////////// */				/* MISSILE CODE */		private function waveHandler():void		{			if(_counter == 30){ // first wave called at 1 second...			   	buildSalvo(6);			   }			if(_counter % 360 == 0){ // new salvo built every 12 seconds...				// update text fields...				// increments wave value every 12 seconds...				waveCount++; 				// score updates a bonus for survival and for number of colonies still alive...				var _colonyBonus:int = _colonies.length;				scoreCount += 10000 + (2500 * _colonyBonus);				// bonus ammo for surviving a wave...				ammoCount += 6;				// call salvo set function increasing its size every wave...				salvoSize += 3;				buildSalvo(salvoSize);			}		}				private function buildSalvo(salvoSize:int):void		{			// adds sound effect			_soundManager.playSound("newWave",0.05);			// loop to create x number of missiles; stops when salvoSize number reached...			for(var i:int = 0; i < salvoSize; i++)			{				addMissile();			}		}				private function addMissile():void		{			// initialise and draw projectile...			var _missile:Missile = new Missile(this);			addChild(_missile);			_missiles.push(_missile);		}				private function missileHandler():void		{			for(var i:int = _missiles.length - 1; i >= 0; i--){				var _missile:Missile = _missiles[i];				// missile speed...				_missile.y += _missile.velY;				_missile.x += _missile.velX;				// missile radius for collision detection function...				var missileRadius:Number = _missile.width / 2;				// remove missile if they reach the ground or fall off the side of the stage...				if(_missile.y >= 700){					removeMissile(i);					addMissileExplosion(_missile.x,700);					return;				} else if(_missile.x <= 0|| _missile.x >=800){					removeMissile(i);					return;				}				// explosion collision detection function...				var hitProjectileExplosion:Boolean = checkForProjectileExplosionCollision(i,_missile.x,_missile.y,missileRadius);				// run further detection code if no explosion collision....				if(!hitProjectileExplosion){ 					checkForColonyCollision(i,_missile.x,_missile.y);				}			}		}				private function addMissileExplosion(xPos:Number,yPos:Number):void		{			addMissileSound();			var _missileExplosion:MissileExplosion = new MissileExplosion(this,xPos,yPos);			addChild(_missileExplosion);			_missileExplosions.push(_missileExplosion);		} 				private function updateMissileExplosions():void		{			// monitors and maintains missile explosions...			for(var i:int = _missileExplosions.length - 1; i >= 0; i--)			{				var _missileExplosion:MissileExplosion = _missileExplosions[i];				if(_missileExplosions[i].removeMe == true){ // check removal flag status...					removeChild(_missileExplosions[i]); // remove from stage...					_missileExplosions[i] = null; // remove from memory...					_missileExplosions.splice(i,1); // remove from array...				}			}		}				private function checkForProjectileExplosionCollision(missileIndex:Number,missileXpos:Number,missileYpos:Number,missileRadius:Number):Boolean		{			// monitors and maintains collisions with projectile explosions...			for(var i:int = _projectileExplosions.length - 1; i >= 0; i--){				var _projectileExplosion:ProjectileExplosion = _projectileExplosions[i];				// check to skip ahead if part of the array has just been removed...				if(!_projectileExplosion)continue;				// calculation for distance between each missile and each explosion...				var dx:Number = missileXpos - _projectileExplosions[i].x; // difference in x				var dy:Number = missileYpos - _projectileExplosions[i].y; // difference in y				var distanceToProjectileExplosion:Number = Math.sqrt((dx*dx) + (dy*dy));				// collision detection using sum of object radii...				var explosionRadius:Number = _projectileExplosions[i].width / 2;				var sumOfRadii:Number = missileRadius + explosionRadius;				// condition for action on collision...				if(distanceToProjectileExplosion <= sumOfRadii){					addMissileExplosion(missileXpos,missileYpos);					removeMissile(missileIndex);					scoreCount += 200; // increments score everytime a missile destroyed...					return true;				}			}			return false;		}				private function checkForColonyCollision(missileIndex:Number,missileXpos:Number,missileYpos:Number)		{			// monitors and maintains collisions with colony objects...			for(var i:int = _colonies.length - 1; i >= 0; i--){				_colony = _colonies[i];				if(_colony.hitTestPoint(missileXpos,missileYpos)){					// adds sound effect					_soundManager.playSound("colonyExplosion",0.2);					// add explosion effect... 					addMissileExplosion(missileXpos,missileYpos);					// and remove missile...					removeMissile(missileIndex);					addSmoke(_colony.x);// add smoke effect					removeColonyFromArray(i); // removes colony from array to prevent further collisions					_colony.gotoAndStop("cracked"); // updates graphic to deaded colony...				}			}		}				private function addSmoke(xPos:Number):void		{			// adds sound particle effect...			_smoke = new Smoke(this,xPos);			addChild(_smoke);		}			private function removeMissile(index:Number):void		{			removeChild(_missiles[index]); // remove from stage...			_missiles[index] = null; // remove from memory...			_missiles.splice(index,1); // remove from array...		} // end of functions	} // end of class} // end of package